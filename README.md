Почему CooperativeStickyAssignor не решает проблему

Эта стратегия лишь смягчает ребалансировку, позволяя:

перебалансировать не всех, а только изменившихся участников;

делать это поэтапно (один консьюмер выходит, перераспределение — и только потом следующий).

Но если консьюмер завис и нарушил max.poll.interval.ms — брокер его кикает, независимо от стратегии. И тогда:

он выброшен из группы,

offset commit больше невозможен,

при ack.acknowledge() → будет CommitFailedException.

***

На первый взгляд, может показаться, что использование ExecutorService должно "спасать" от таймаута max.poll.interval.ms, ведь вы «быстро» возвращаете управление из метода listen. Но на самом деле это не так.

Почему ExecutorService.submit(...) не помогает избежать таймаута max.poll.interval.ms?
Kafka считает, что consumer всё ещё обрабатывает сообщение, пока:

Вы не вызвали ack.acknowledge().

А сам метод @KafkaListener не вернул управление (если ack-mode не manual_immediate).

В вашем случае:

Вы делегируете обработку в отдельный поток.

Но ack.acknowledge() вызывается в фоне, не в основном consumer thread.

Kafka всё это время ждёт коммита (и poll() вызова), и если max.poll.interval.ms превышен — consumer кикается из группы, даже если он «обрабатывает» что-то в фоне.

Ключевая проблема:
@KafkaListener метод быстро завершается, но не делает poll(), и не коммитит offset, т.к. это делается позже в background-потоке.

Kafka не знает, что вы что-то обрабатываете — для него consumer просто завис и не пуллит.